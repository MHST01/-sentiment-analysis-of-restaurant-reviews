# -*- coding: utf-8 -*-
"""sentimental analysis of restaurant_reviews.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12VgI0DqgtrZYsQnlFQkbAW4DfGOjtxcw
"""

import numpy as np
import pandas as pd

"""IMPORTING  DATASET"""

from google.colab import files
uploaded = files.upload()

import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score

"""loading the dataset"""

df=pd.read_csv('Restaurant_ reviews.csv', encoding = "ISO-8859-1")

df.shape

df.head()

hs=df.copy()

hs.info()

""" CLEANING AND PROCESSING OF DATA"""

dfs= df.drop(columns=["Time","Pictures","Metadata","Reviewer"])

train_y=dfs["Rating"]

train_x=dfs.drop(columns=["Rating"])
train_x

dfs.head()

train_y=train_y.replace({'Like':3})

train_y.isnull().sum()

hs['Rating'].value_counts().plot.bar(color = 'blue')

train_y=pd.to_numeric(train_y)
train_y=train_y.fillna(train_y.median())

"""Assigning reviews( positive, negative and neutral)"""

for i in range(0,len(train_y)):
   train_y.iloc[i] = round(train_y.iloc[i],0)
for i in range(0,len(train_y)):
    if (train_y[i]>3):
        train_y[i] = 2 #Positive review
    elif (train_y[i]==3):
        train_y[i] = 1 #Neutral review
    else:
        train_y[i] = 0 #Negative review

"""CLEANING AND PREPROCESSING THE TEXT DATA"""

# Importing essential libraries for NPL(Natural Language Processing)
import re
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer
ps = PorterStemmer()  #Stemming
corpus = []
for i in range(0, len(train_x)):
    review = re.sub('[^a-zA-Z]',' ', str(train_x['Review'][i]))
    review = review.lower()
    review = review.split()
    review = [ps.stem(word) for word in review if not word in stopwords.words('english')]
    review = ' '.join(review)
    corpus.append(review)

"""Creating the Bag of words model"""

from sklearn.feature_extraction.text import CountVectorizer
cv = CountVectorizer(max_features=9000)
X = cv.fit_transform(corpus).toarray()

from sklearn.feature_extraction.text import TfidfVectorizer
vectorizer = TfidfVectorizer()
train_x= vectorizer.fit_transform(corpus)

"""Train && Test && Split...!"""

from sklearn.model_selection import train_test_split
X, Xtest, y, ytest = train_test_split(X, train_y, test_size=0.3, random_state=0)

"""Applying Naive Bayes Algorithm"""

from sklearn.naive_bayes import MultinomialNB
restaurant_review_model = MultinomialNB().fit(X,y)#creation of the model

y_predict = restaurant_review_model.predict(Xtest)#predicting the test dataset values

"""Confusion Matrix"""

from sklearn.metrics import confusion_matrix
conf_mat = confusion_matrix(ytest, y_predict)

print(conf_mat)

"""Plotting graph for the Confusion Matrix"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
plt.figure(figsize=(10,8))
sns.heatmap(conf_mat,annot=True,cmap="YlGnBu",xticklabels=['Negative','Positive'],yticklabels=['Negative','Positive'])
plt.xlabel('Predicted values')
plt.ylabel('Actual values')

"""Calculating Accuracy_Score"""

from sklearn.metrics import accuracy_score
accuracy = accuracy_score(ytest, y_predict)
print(accuracy*100)

"""Classification report of the Dataset"""

from sklearn import metrics
print("Classfication Metrics:\n")
print(metrics.classification_report(ytest, y_predict))

"""Predictions...!"""

def predict_sentiment(sample_review):
  sample_review = re.sub(pattern='[^a-zA-Z]',repl=' ', string = sample_review)
  sample_review = sample_review.lower()
  sample_review_words = sample_review.split()
  sample_review_words = [word for word in sample_review_words if not word in set(stopwords.words('english'))]
  ps = PorterStemmer()
  final_review = [ps.stem(word) for word in sample_review_words]
  final_review = ' '.join(final_review)

  temp = cv.transform([final_review]).toarray()
  return restaurant_review_model.predict(temp)

# Predicting positive reviews and  negative reviews ...!
sample_review = 'The food is really good here.'

if predict_sentiment(sample_review):
  print('This is a POSITIVE review.')
else:
  print('This is a NEGATIVE review!')

# Predicting positive reviews and  negative reviews ...!
sample_review = 'Food was pretty bad and the service was very slow.'

if predict_sentiment(sample_review):
  print('This is a POSITIVE review.')
else:
  print('This is a NEGATIVE review!')